{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Chiffrement et base 64","text":"<p>Le chiffrement moderne repose sur des algorithmes plus robustes que ceux \u00e9tudi\u00e9s en classe.</p> <p> </p> <p>On apprend dans ce TP \u00e0 utiliser des outils existants pour chiffrer de fa\u00e7on efficace nos donn\u00e9es.</p>"},{"location":"#pour-commencer","title":"Pour commencer","text":"<p>OpenSSL est une bo\u00eete \u00e0 outils de chiffrement comportant deux biblioth\u00e8ques fournissant respectivement une impl\u00e9mentation des algorithmes cryptographiques et du protocole de communication SSL/TLS, ainsi qu\u2019une interface en ligne de commande : openssl.</p> <p>Important</p> <p>La biblioth\u00e8que de chiffrement web open source OpenSSL est affect\u00e9e par une vuln\u00e9rabilit\u00e9 pouvant servir \u00e0 des attaques par d\u00e9ni de service. Les versions 1.0.2, 1.1.1 et 3.0 doivent \u00eatre mises \u00e0 jour d\u00e8s que possible.</p>"},{"location":"#lencodage-64-bits","title":"L'encodage 64 bits","text":"<p>L\u2019encodage en base 64 consiste \u00e0 coder chaque groupe de 24 bits successifs de donn\u00e9es par une cha\u00eene de 4 caract\u00e8res. On proc\u00e8de du d\u00e9but \u00e0 la fin, en concat\u00e9nant 3 octets pour cr\u00e9er un seul groupement de 24 bits. Ils sont alors s\u00e9par\u00e9s en 4 nombres de seulement 6 bits. Chacune des 4 valeurs est enfin repr\u00e9sent\u00e9e (cod\u00e9e) par un caract\u00e8re de la table ci-dessous :</p> <p> </p> <p>Par exemple, pour chiffrer le mot \u00ab NSI \u00bb on commence par l\u2019\u00e9crire en binaire avec la table ASCII :</p> <p> N S I 01001110 01010011 01001001 <p></p> <p>que l'on d\u00e9coupe ensuite en paquet de 6 bits :</p> <p> Paquet 1 Paquet 2 Paquet 3 Paquet 4 010011 100101 001101 001001 <p></p> <p>on r\u00e9cup\u00e8re alors les caract\u00e8res associ\u00e9s dans la table :</p> <p> Paquet 1 Paquet 2 Paquet 3 Paquet 4 T I N J <p></p> <p>Warning</p> <p>Un traitement sp\u00e9cial est effectu\u00e9 si moins de 24 bits sont disponibles \u00e0 la fin de la s\u00e9quence de donn\u00e9es \u00e0 coder (elle n\u2019a pas forc\u00e9ment une taille multiple de 24 bits). Dans un tel cas, des z\u00e9ros sont ajout\u00e9s \u00e0 la droite des donn\u00e9es initiales pour aller vers le multiple de 6 bits le plus proche. Chaque paquet de 6 bits est converti dans l\u2019alphabet. Puis on ajoute des caract\u00e8res \u00ab = \u00bb compl\u00e9mentaires pour former quand m\u00eame 4 caract\u00e8res.</p> <p>Pour commencer</p> <ol> <li>Encoder le mot TARANTINO en base 64.</li> <li>D\u00e9coder le mot UkFDTEVUVEU= qui a \u00e9t\u00e9 encod\u00e9 en base 64.</li> </ol>"},{"location":"#avec-openssl","title":"Avec OpenSSL","text":"<p>OpenSSL s\u2019utilise dans un terminal Linux. Il se pr\u00e9sente sous la forme d\u2019un programme en ligne de commande auquel on passe quelques options et param\u00e8tres.  </p> <p>Par exemple, pour encoder le texte \"La raclette est moelleuse !\", on \u00e9crit :</p> Utilisation d'OpenSSL dans un terminal<pre><code>echo -n \"La raclette est moelleuse !\" | openssl enc -base64\n</code></pre> <p>et on obtient TGEgcmFjbGV0dGUgZXN0IG1vZWxsZXVzZSAh.  </p> <p>Important</p> <p>L'option <code>-n</code> permet de ne pas prendre en compte le retour chariot (lorsqu'on valide avec la touche Entrer).</p> <p>Pour d\u00e9coder, un texte encod\u00e9 avec la base 64, on ajoute l'option <code>-d</code> et on enl\u00e8ve l'option <code>-n</code> :</p> Utilisation d'OpenSSL dans un terminal<pre><code>echo \"SidhZG9yZSBsZXMgcG9tbWVzIGQnYW1vdXIgIQ==\" | openssl enc -base64 -d\n</code></pre> <p>Note</p> <p>Je vous laisse d\u00e9couvrir le message.</p> <p>Il est \u00e9galement possible d\u2019encoder des fichiers entiers.  </p> <p>Avec des fichiers</p> <ol> <li>Commencer par t\u00e9l\u00e9charger le fichier tirade.txt. et placer le dans votre r\u00e9pertoire de travail.</li> <li> <p>Ouvrir un terminal dans ce dossier et tester la commande :</p> OpenSSL et fichiers<pre><code>openssl enc -base64 -in tirade.txt -out tirade.b64\n</code></pre> <p>Observer alors le contenu du fichier tirade.b64 \u00e0 l'aide de la commande </p> OpenSSL et fichiers<pre><code>cat tirade.b64\n</code></pre> </li> <li> <p>D\u00e9chiffrer ce nouveau fichier \u00e0 l'aide de la commande :</p> OpenSSL et fichiers<pre><code>openssl enc -base64 -d -in tirade.b64 -out tirade_dechiffre.txt\n</code></pre> </li> <li> <p>T\u00e9l\u00e9charger le fichier secret.b64, d\u00e9coder le puis chanter.</p> </li> </ol>"},{"location":"#application-pour-les-mails","title":"Application pour les mails","text":"<p>Lors de l\u2019envoi d\u2019email, les images en pi\u00e8ce jointe sont souvent encod\u00e9es en base64. On a justement intercept\u00e9 l'email d'un \u00e9l\u00e8ve de NSI dans lequel se trouvait une image (encod\u00e9e en base 64).</p> <p> </p> <p>Avec des images</p> <ol> <li>T\u00e9l\u00e9charger le fichier image.b64.</li> <li>D\u00e9coder la gr\u00e2ce \u00e0 OpenSSL (c'est une image png).</li> </ol>"},{"location":"#utiliser-des-chiffrements-modernes","title":"Utiliser des chiffrements modernes","text":""},{"location":"#presentation-de-blowfish","title":"Pr\u00e9sentation de Blowfish","text":"<p>Blowfish est un algorithme de chiffrement sym\u00e9trique par blocs con\u00e7u par Bruce Schneier en 1993.</p> <p>Blowfish utilise une taille de bloc de 64 bits et la cl\u00e9 de longueur variable peut aller de 32 \u00e0 448 bits. Elle est bas\u00e9e sur l\u2019id\u00e9e qu\u2019une bonne s\u00e9curit\u00e9 contre les attaques de cryptanalyse peut \u00eatre obtenue en utilisant de tr\u00e8s grandes cl\u00e9s pseudo-al\u00e9atoires.</p>"},{"location":"#avec-openssl_1","title":"Avec OpenSSL","text":"<p>On cherche \u00e0 chiffrer l'image ci-dessous avec l'algorithme Blowfish.</p> <p> </p> <p>Question</p> <ol> <li>Commencer par t\u00e9l\u00e9charger l'image en cliquant sur le lien.</li> <li> <p>Une fois dans le terminal (au bon endroit), taper la commande :</p> OpenSSL et Blowfish<pre><code>openssl enc -bf -in kb.png -out kb.bf -provider legacy -provider default\n</code></pre> <p>Attention</p> <p>Apr\u00e8s validation, il vous sera demand\u00e9 de taper un mot de passe. Taper le (il n'appara\u00eet pas, c'est normal) et valider.  </p> <p>Vous aurez besoin de ce mot de passe pour d\u00e9chiffrer l'image.</p> </li> <li> <p>D\u00e9chiffrer alors le fichier kb.bf \u00e0 l'aide de la commande :</p> OpenSSL et Blowfish<pre><code>openssl enc -bf -d -in kb.bf -out kb_dechiffre.png -provider legacy -provider default\n</code></pre> <p>Information</p> <p>Votre mot de passe a \u00e9t\u00e9 demand\u00e9 ici !</p> </li> </ol>"},{"location":"#pour-aller-plus-loin","title":"Pour aller plus loin","text":"<p>Nous sommes \u00e0 la recherche d'une image secr\u00e8te.  </p> <p> </p> <p>Voici les diff\u00e9rentes \u00e9tapes r\u00e9alis\u00e9es sur cette image :</p> <ul> <li>Elle a d'abord \u00e9t\u00e9 encod\u00e9e en base 64 ;</li> <li>On a chiffr\u00e9 l'image encod\u00e9e avec Blowfish et le mot de passe utilis\u00e9 est UmFjbGV0dGU= (\u00e0 d\u00e9coder avant d'\u00eatre utilis\u00e9) ;</li> </ul> <p>Question</p> <ol> <li>T\u00e9l\u00e9charger l'image myst\u00e8re en cliquant sur ce lien</li> <li>Retrouver l'image originale. (Il s'agit d'un gif.)</li> </ol>"}]}